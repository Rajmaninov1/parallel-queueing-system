# -*- coding: utf-8 -*-
"""simulacion_multiple_servers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tcTD_tAGMK7CTf1Z_UmAEaVJHFoPsFXj
"""

import argparse

import numpy as np
import pandas as pd
import scipy.stats as st
import simpy
from tqdm import tqdm


class System(object):
    def __init__(self, env, num_servers, arrival_time, policy):
        self.env = env
        self.queue = Queue(arrival_time)
        self.servers = Servers(num_servers)
        self.policy = getPolicy(policy)

    def Simulation(self):
        self.env.process(self.queue.generateCustomer(self.env))
        scheduler = self.policy
        while True:
            # check if there are customers in queue and server available
            if len(self.queue.customers) and len(self.servers.availableServers):
                # get customer based on policy
                customer = scheduler(self.queue)
                # send customer to server
                self.env.process(self.servers.ServeCustomer(self.env, customer, self.queue))

            yield self.env.timeout(0.1)


def serverStats(availableServers, totalTime=4800, num_servers=5):
    total_service_time = 0
    avg_busy_time = 0
    for server in availableServers:
        avg_busy_time += server.TotalServiceTime / totalTime
    return avg_busy_time / num_servers


def customerStat(queue):
    all_customers = queue.customerServerd
    arrival_time = []
    time_spent = []
    numOfSatisfied = 0
    for customer in all_customers:
        arrival_time.append(customer.interarrival_time)
        time_spent.append(customer.timeSpent)
        if (customer.num_of_services == 1):
            numOfSatisfied += 1

    return arrival_time, time_spent, numOfSatisfied


def saveSystemStat(dic, system):
    arrival_time, timeSpent, satisfiedCustomer = customerStat(system.queue)
    dic["numCustomer"].append(len(timeSpent))

    dic["totalTimeInSys"].append(sum(timeSpent) / len(timeSpent))
    dic["maxTimeInSys"].append(max(timeSpent))

    # total num of satisfied customer
    dic["numSatisfied"].append(satisfiedCustomer)
    # queue stats
    dic["avgQueueLen"].append(sum(system.queue.numCustomer) / len(system.queue.numCustomer))
    dic["maxQueueLen"].append(system.queue.maxLen)

    # average server busy time
    dic["meanBusyTime"].append(serverStats(system.servers.availableServers))

    # max number of busy server
    dic["maxBusyServer"].append(system.queue.maxNumBusyServer)


def showSystemStats(dic):
    variables = dic.keys()
    dataframe = {"variables": [], "mean": [], "stander deviation": [], "confidence interval 95%": []}
    for variable in list(variables):
        mean, std, confidenceInterval = variableStats(dic[variable])
        dataframe["variables"].append(variable)
        dataframe["mean"].append(mean)
        dataframe["stander deviation"].append(std)
        dataframe["confidence interval 95%"].append(confidenceInterval)
    dataframe = pd.DataFrame(dataframe)
    dataframe.set_index("variables")
    pd.set_option('display.max_columns', None)
    print(dataframe)


def variableStats(list_):
    mean = np.mean(list_)
    std = np.std(list_)
    confidenceInterval = st.t.interval(0.95, len(list_) - 1, loc=np.mean(list_), scale=st.sem(list_))

    return mean, std, confidenceInterval


def priority_(queue):
    queue.customers = sorted(queue.customers, key=lambda customer: customer.num_of_services, reverse=True)
    return queue.customers.pop(0)


def FIFO(queue):
    return queue.customers.pop(0)


def getPolicy(policy):
    if policy == "FIFO":
        return FIFO

    elif policy == "Priority":
        return priority_


class Customer():
    def __init__(self):
        self.num_of_services = 0
        self.a = 2
        self.b = 2.8
        self.serviceTime = []
        self.timeSpent = 0
        self.arrival_timeStamp = 0
        self.interarrival_time = 0

    def calculateServiceTime(self):
        a = (self.a) / (1 + self.num_of_services)
        b = (self.b) / (1 + self.num_of_services)
        serviceTime = np.random.uniform(a, b)
        return serviceTime


class Queue():
    def __init__(self, meanArrivalTime=5):
        self.customers = []
        self.maxLen = 0
        self.customerServerd = []
        self.available = 1
        self.maxNumBusyServer = 0
        self.numCustomer = []
        self.meanArrivalTime = meanArrivalTime

    def updateMaxLen(self):
        if (len(self.customers) > self.maxLen):
            self.maxLen = len(self.customers)

    def generateCustomer(self, env):
        id = 0
        while (self.available):
            arrival_time = np.random.exponential(self.meanArrivalTime)
            yield env.timeout(arrival_time)
            c = Customer()
            c.arrival_timeStamp = env.now
            c.interarrival_time = arrival_time
            c.id = id
            id += 1
            self.customers.append(c)
            if (len(self.customers) > self.maxLen):
                self.maxLen = len(self.customers)
            self.numCustomer += [len(self.customers)]

        return 0


class Server():
    def __init__(self):
        self.TotalServiceTime = 0
        self.numCustomer = 0


class Servers():
    def __init__(self, num_servers=5):
        self.availableServers = [Server() for i in range(num_servers)]
        self.num_servers = num_servers

    # server customer using one of the servers available
    def ServeCustomer(self, env, customer, queue):
        server = self.availableServers.pop(0)
        if ((self.num_servers - len(self.availableServers)) > queue.maxNumBusyServer):
            queue.maxNumBusyServer = self.num_servers - len(self.availableServers)
        serviceTime = customer.calculateServiceTime()
        customer.serviceTime.append(serviceTime)
        server.TotalServiceTime += serviceTime
        server.numCustomer += 1
        yield env.timeout(serviceTime)
        # release server
        self.availableServers.append(server)
        # check if customer is satisfied
        choices = [0, 1]
        p = 0.2 / (1 + customer.num_of_services)
        probabilities = [p, 1 - p]
        satisfied = np.random.choice(choices, 1, p=probabilities)
        customer.num_of_services += 1
        if not satisfied:
            customer.timeSpent += serviceTime
            queue.customers.append(customer)
            if (len(queue.customers) > queue.maxLen):
                queue.maxLen = len(queue.customers)
        else:
            customerArrivalTime = customer.arrival_timeStamp
            timeNow = env.now
            customer.timeSpent = timeNow - customerArrivalTime
            queue.customerServerd.append(customer)
        return 0

parser = argparse.ArgumentParser()
parser.add_argument('-f')
parser.add_argument('--num_servers', type=int, default=5)
parser.add_argument('--arrival_time', type=int, choices=range(2, 15), default=5)
parser.add_argument('--iteration', type=int, choices=range(100, 10000), default=200)
parser.add_argument('--policy', type=str, choices=["FIFO", "Priority"], default="FIFO")
args = parser.parse_args()
iteration = args.iteration
num_servers = args.num_servers
arrival_time = args.arrival_time
policy = args.policy
print("num of Servers in the system =", num_servers)
print("customer mean arrival =", arrival_time)

dic = {"numSatisfied": [],
        "totalTimeInSys": [],
        "numCustomer": [],
        "maxTimeInSys": [],
        "avgQueueLen": [],
        "maxQueueLen": [],
        "meanBusyTime": [],
        "maxBusyServer": []}

# number of repetition the more, the better
n = iteration

for i in tqdm(range(n)):
    env = simpy.Environment()
    system = System(env, num_servers, arrival_time, policy)
    env.process(system.Simulation())
    env.run(until=4800)

    saveSystemStat(dic, system)

print("\n")
showSystemStats(dic)

df = pd.DataFrame.from_dict(dic)
df
